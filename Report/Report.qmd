---
title: "Data Management Group Assignment (IB9HP0)"
format: pdf
editor: visual
author: "Group 2"
---

### Introduction

This report simulates the end-to-end data management for an e-commerce platform in US from database design, workflow management to data analysis that provides insights into the platform's key performance metrics.

[**any key highlight from the analysis**]{.underline}

### Overview

![](flowchart.png)

### Part 1: Database Design and Implementation

#### Task 1.1: E-R Diagram Design

![ER Diagram](ER%20Diagram.jpg)

![Entity Relationship Sets](Entity%20Relationship%20Sets.png)

Our database conceptual design is based on the following assumptions & justification:

-   Customers are unique and identified by their ID. Each customer must have their first name, last name and email address whereas can opt to provide phone number or date of birth. For simplification we assume no multivalued attributes; thus, only one billing address, current shipping address and current payment method are captured in the database.
-   Products are organised into unique categories, which are identified by category ID. Each product belongs to only one category whilst one category can include multiple products, forming the 1:N relationship between Categories and Products entity.
-   Identical items sold by different sellers are considered different products and have unique product ID. Thus, one product can have only one seller but one seller may distribute multiple products, forming the 1:N relationship between Sellers and Products entity. This conceptual design is important to track price and inventory for each product sold by each seller. Additionally, each product can also have name, color, size and brand.
-   Sellers are unique and identified by their ID. We capture sellers' email, name and address.
-   Advertisements (unique and identified by ID) are specific for each product but one product can have multiple advertisements, forming the 1:N relationship between Products and Advertisements entity. Each advertisement must specify budget and captures content and the number of ad clicks.
-   Multiple customers can order multiple products that will be delivered to them by a selection of shippers (e.g., depending on the warehouse location), forming the ternary M:N relationship among the three entities. Each time a customer commits an order of a specific product which will be delivered by an assigned shipper, a unique order ID will be generated.
-   Each order captures quantity, date and time, and discount rate applicable specifically to the order. A customer can only leave a review on a product if he/she has ordered it. Thus, rating_reviews must be specific to an order, forming an attribute of the Orders relationship.
-   None of derived attributes are included to ensure physical schema comprise of only atomic values thus in normalized form.

#### Task 1.2: SQL Database Schema Creation

-   **Customers** ($\underline{id}$, date_of_birth, first_name, last_name, phone_number, email, billing_address_street_number, billing_address_street_name, billing_address_street_suffix, billing_address_city, billing_address_state, billing_address_country, billing_address_postcode, current_shipping_address_street_number, current_shipping_address_street_name, current_shipping_address_street_suffix, current_shipping_address_city, current_shipping_address_state, current_shipping_address_country, current_shipping_address_postcode, current_payment_method)
-   **Shippers** ($\underline{id}$, name, phone_number)
-   **Products** ($\underline{id}$, $\underline{\underline{seller\_id}}$, $\underline{\underline{category\_id}}$, name, color, size, brand, price, currency, inventory)
-   **Order** ($\underline{id}$, $\underline{\underline{customer\_id}}$ , $\underline{\underline{product\_id}}$ , $\underline{\underline{shipper\_id}}$[,]{.underline} order_date, order_time, quantity, discount, rating_review)
-   **Seller** ($\underline{id}$, name, email, address_street_number, address_street_name, address_street_suffix, address_city, address_state, address_country, address_postcode)
-   **Advertisements** ($\underline{id}$, $\underline{\underline{product\_id}}$[,]{.underline} content, ad_clicks, budget, currency)
-   **Categories** ($\underline{id}$[,]{.underline} name, description)

Our logical design of the database is converted from the conceptual ER diagram on the following principles:

-   Primary keys are underlined whereas foreign keys are double underlined.

-   The primary key of the weak side become the foreign key on the strong side of the cardinality.

-   Composite attributes (customer name, customer and seller address, product price and advertisement budget ) are registered in individual fields using outer layer of the attribute to ensure that physical database only capture atomic value.

-   Each entity is converted into one table. Except for the Orders relationship, all other cardinality relationship are 1:N thus not converted into table.

-   The ternary M:N relationship among Customers, Products and Shippers is converted into the Orders table

[**Schema Creation are performed as below code:**]{.underline}

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE,comment=NA,attr.source='.numberLines')

rm(list=ls())
library(readr)
library(RSQLite)
library(dplyr)
library(ggplot2)
library(lubridate)
library(treemapify)

```

```{r connection}
# 1. set up the connection
my_db <- RSQLite::dbConnect(RSQLite::SQLite(),"../database/ecommerce.db")

```

```{bash schema, eval=FALSE}
# 2. link to SQL file to write the schema
sqlite3 "../database/ecommerce.db" < "../main/ecommerce.sql"
```

The code in **ecommerse.sql** file are shown below:

```{sql connection=my_db, eval=FALSE}
DROP TABLE IF EXISTS `customers` ;
DROP TABLE IF EXISTS `products` ;
DROP TABLE IF EXISTS `shippers` ;
DROP TABLE IF EXISTS `orders` ;
DROP TABLE IF EXISTS `advertisements` ;
DROP TABLE IF EXISTS `sellers` ;
DROP TABLE IF EXISTS `categories` ;
```

The table creation sequence starts with tables that do not have foreign keys.
```{sql connection=my_db, eval=FALSE}

------------- CREATE TABLE -------------

-- Customer Schema
CREATE TABLE IF NOT EXISTS `customers` (
  'id' INT PRIMARY KEY,
  'first_name' VARCHAR(250) NOT NULL,
  'last_name' VARCHAR(250) NOT NULL,
  'email' TEXT NOT NULL,
  'phone_number' VARCHAR(20),
  'date_of_birth' DATE,
  'billing_address_street_number' TEXT,
  'billing_address_street_name' TEXT,
  'billing_address_street_suffix' TEXT,
  'billing_address_city' TEXT,
  'billing_address_state' TEXT,
  'billing_address_country' TEXT,
  'billing_address_postcode' TEXT,
  'current_shipping_address_street_number' TEXT,
  'current_shipping_address_street_name' TEXT,
  'current_shipping_address_street_suffix' TEXT,
  'current_shipping_address_city' TEXT,
  'current_shipping_address_state' TEXT,
  'current_shipping_address_country' TEXT,
  'current_shipping_address_postcode' TEXT,
  'current_payment_method' VARCHAR(250)
);

-- Sellers Schema
CREATE TABLE IF NOT EXISTS `sellers` (
  'id' INT PRIMARY KEY,
  'name' VARCHAR(250) NOT NULL,
  'email' TEXT,
  'address_street_number' TEXT,
  'address_street_name' TEXT,
  'address_street_suffix' TEXT,
  'address_city' TEXT,
  'address_state' TEXT,
  'address_country' TEXT,
  'address_postcode' TEXT
);

-- Categories Schema
CREATE TABLE IF NOT EXISTS `categories` (
  'id' INT PRIMARY KEY,
  'name' VARCHAR(250) NOT NULL,
  'description' TEXT
);

-- Products Schema
CREATE TABLE IF NOT EXISTS `products` (
  'id' INT PRIMARY KEY,
  'seller_id' INT NOT NULL,
  'category_id' INT NOT NULL,
  'name' VARCHAR(60) NOT NULL,
  'color' VARCHAR(60) NOT NULL,
  'size' VARCHAR(5),
  'brand' VARCHAR(250),
  'price' NUMERIC NOT NULL,
  'currency' CHAR(3) NOT NULL, 
  'inventory' INT NOT NULL,
  FOREIGN KEY ('seller_id') 
    REFERENCES sellers ('id'),
  FOREIGN KEY ('category_id') 
    REFERENCES categories ('id')
);

-- Shipper Schema
CREATE TABLE IF NOT EXISTS `shippers` (
  'id' INT PRIMARY KEY,
  'name' CHAR(25) NOT NULL,
  'phone_number' VARCHAR(25) NOT NULL
);

-- Order Schema : create after 3 main tables
CREATE TABLE IF NOT EXISTS `orders` (
  'id' INT PRIMARY KEY,
  'customer_id' INT NOT NULL,
  'product_id' INT NOT NULL,
  'shipper_id' INT NOT NULL,
  'order_date' DATE NOT NULL,
  'order_time' TIMESTAMP NOT NULL,
  'quantity' INT NOT NULL,
  'discount' DECIMAL(3,2) NOT NULL,
  'rating_review' INT,
  FOREIGN KEY ('customer_id')
    REFERENCES customers ('id'),
  FOREIGN KEY ('product_id')
    REFERENCES products ('id'),
  FOREIGN KEY ('shipper_id')
    REFERENCES shippers ('id')
);

-- Ads Schema
CREATE TABLE IF NOT EXISTS `advertisements` (
  'id' INT PRIMARY KEY,
  'product_id' INT NOT NULL,
  'content' TEXT,
  'ad_clicks' INT,
  'budget' DECIMAL(10,2),
  'currency' CHAR(3),
  FOREIGN KEY ('product_id')
	REFERENCES products ('id')
);
```

#### Part 2: Data Generation and Management

#### Task 2.1: Synthetic Data Generation

The entire synthetic data is generated using Mockaroo using advanced field settings or Mockaroo specified coding language.

Foreign key is imported from other datasets by using field type as 'Dataset Column' then connecting to the other datasets where the foreign key comes from.

Field type as 'Formula' or 'Custom List' with dynamic distribution are utilised to set specific rules and conditions for the synthetic data generation as realistic as possible, for example:

-   Product names are conditional to category ID

-   Product size and price ranges are conditional to product name

-   Advertisement contents are conditional to product name

The data generation is a part of the dynamic process from data generation to data validation then data analysis. Data generation is revised whenever challenges incur during validation and analysis to ensure that the synthetic data simulates the real-world as much as possible.

#### Task 2.2: Data Import and Quality Assurance

### Part 3: Data Pipeline Generation

#### Task 3.1: GitHub Repository and Workflow Setup

For setting up the GitHub repository and workflow, we first create a new repository for our project on GitHub, and then clone it to our local machine using Git. This enables collaboration within our group, allowing everyone to work together and make changes to the project through GitHub. After cloning the repository locally, we add our database file, e-commerce data file, report file, as well as scripts for data validation, transformation, data analysis, and data visualization to the repository. 

Within the 'database' file, an e-commerce database is created, and in the 'data upload' file, we upload all the generated data, including tables: advertisements, categories, customers, products, sellers, shippers. Within the ‘main’ file, we have data analysis visualizations file, and transformation, validation scripts.

#### Task 3.2: GitHub Actions for Continuous Integration

### Part 4: Data Analysis and Reporting with Quarto in R

#### Task 4.1: Advanced Data analysis in R

#### Task 4.2: Comprehensive Reporting with Quarto

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
1 + 1
```

```{r}

```

You can add options to executable code like this

```{r}
#| echo: false
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).
