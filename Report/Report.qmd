---
title: "Data Management Group Assignment (IB9HP0)"
format: pdf
editor: visual
author: "Group 2"
---

### Introduction

This report simulates the end-to-end data management for an e-commerce platform in US from database design, workflow management to data analysis that provides insights into the platform's key performance metrics.

### Overview

![](flowchart.png)

This is the entire process of project, it begins with the database design phase, which includes conceptual, logical, and physical design. During conceptual design, we translate our understanding of the e-commerce database into an E-R. In the logical design phase, we define the structure of the database. For the physical design phase, we create the physical schema.

After designing the database, we perform the initial load of generated synthetic data and import it into the database tables, while also conducting validation check. Subsequently, we execute queries to retrieve, manipulate, and manage the data stored in the database. Finally, we conduct data analysis on our e-commerce data.

In the incremental load process, new synthetic data is generated and subjected to validation checks. If valid, the corresponding database tables and analysis graphs are updated accordingly.

### Part 1: Database Design and Implementation

#### Task 1.1: E-R Diagram Design

**Conceptual Design**

![ER Diagram](ER%20Diagram.png)

![Entity Relationship Sets](Entity%20Relationship%20Sets.png)

Our database conceptual design is based on the following assumptions & justification:

-   Customers are unique and identified by their ID. Each customer must have their first name, last name and email address whereas can opt to provide phone number or date of birth. For simplification we assume no multivalued attributes; thus, only one billing address, current shipping address and current payment method are captured in the database.
-   Products are organised into unique categories, which are identified by category ID. Each product belongs to only one category whilst one category can include multiple products, forming the 1:N relationship between Categories and Products entity.
-   Identical items sold by different sellers are considered different products and have unique product ID. Thus, one product can have only one seller but one seller may distribute multiple products, forming the 1:N relationship between Sellers and Products entity. This conceptual design is important to track price and inventory for each product sold by each seller. Additionally, each product can also have name, color, size and brand.
-   Sellers are unique and identified by their ID. We capture sellers' email, name and address.
-   Advertisements (unique and identified by ID) are specific for each product but one product can have multiple advertisements, forming the 1:N relationship between Products and Advertisements entity. Each advertisement must specify budget and captures content and the number of ad clicks.
-   Multiple customers can order multiple products that will be delivered to them by a selection of shippers (e.g., depending on the warehouse location), forming the ternary M:N relationship among the three entities. Each time a customer commits an order of a specific product which will be delivered by an assigned shipper, a unique order ID will be generated.
-   Each order captures quantity, date and time, and discount rate applicable specifically to the order. A customer can only leave a review on a product if he/she has ordered it. Thus, rating_reviews must be specific to an order, forming an attribute of the Orders relationship.
-   None of derived attributes are included to ensure physical schema comprise of only atomic values thus in normalized form.

**Logical Design**

-   **Customers** ($\underline{id}$, date_of_birth, first_name, last_name, phone_number, email, billing_address_street_number, billing_address_street_name, billing_address_street_suffix, billing_address_city, billing_address_state, billing_address_country, billing_address_postcode, current_shipping_address_street_number, current_shipping_address_street_name, current_shipping_address_street_suffix, current_shipping_address_city, current_shipping_address_state, current_shipping_address_country, current_shipping_address_postcode, current_payment_method)
-   **Shippers** ($\underline{id}$, name, phone_number)
-   **Products** ($\underline{id}$, $\underline{\underline{seller\_id}}$, $\underline{\underline{category\_id}}$, name, color, size, brand, price, currency, inventory)
-   **Order** ($\underline{id}$, $\underline{\underline{customer\_id}}$ , $\underline{\underline{product\_id}}$ , $\underline{\underline{shipper\_id}}$[,]{.underline} order_date, order_time, quantity, discount, rating_review)
-   **Seller** ($\underline{id}$, name, email, address_street_number, address_street_name, address_street_suffix, address_city, address_state, address_country, address_postcode)
-   **Advertisements** ($\underline{id}$, $\underline{\underline{product\_id}}$[,]{.underline} content, ad_clicks, budget, currency)
-   **Categories** ($\underline{id}$[,]{.underline} name, description)

Our logical design of the database is converted from the conceptual ER diagram on the following principles:

-   Primary keys are underlined whereas foreign keys are double underlined.

-   The primary key of the weak side become the foreign key on the strong side of the cardinality.

-   Composite attributes (customer name, customer and seller address, product price and advertisement budget ) are registered in individual fields using outer layer of the attribute to ensure that physical database only capture atomic value.

-   Each entity is converted into one table. Except for the Orders relationship, all other cardinality relationship are 1:N thus not converted into table.

-   The ternary M:N relationship among Customers, Products and Shippers is converted into the Orders table. Primary key (ID) of Customers, Entities and Shippers entity, together with order date and time forming a composite key for the Orders relationship table. Each record of the Orders relationship is also unique by an order ID.

#### Task 1.2: SQL Database Schema Creation

The physical schema is in First Normal Form (1NF) as:

-   Each column of a table is a unique variable and contains only atomic values (due to no composite or multivalued attribute in the logical schema).

-   Each row of a table is a unique record and identified by value in its ID attribute.

-   The order of rows and columns is not significant.

The physical schema is in Second Normal Form (2NF) and Third Normal Form (3NF) as each table are in 1NF and there are no undesirable functional dependency among the tables i.e., there is no non-prime attribute is directly or transitively partially dependent on a candidate key.

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE,comment=NA,attr.source='.numberLines')

rm(list=ls())
library(readr)
library(RSQLite)
library(dplyr)
library(ggplot2)
library(lubridate)
library(treemapify)

```

```{r connection}
# 1. set up the connection
my_db <- RSQLite::dbConnect(RSQLite::SQLite(),"../database/ecommerce.db")

```

```{bash schema, eval=FALSE}
# 2. link to SQL file to write the schema
sqlite3 "../database/ecommerce.db" < "../main/ecommerce.sql"
```

The code in **ecommerse.sql** file are shown below:

```{sql connection=my_db, eval=FALSE}
DROP TABLE IF EXISTS `customers` ;
DROP TABLE IF EXISTS `products` ;
DROP TABLE IF EXISTS `shippers` ;
DROP TABLE IF EXISTS `orders` ;
DROP TABLE IF EXISTS `advertisements` ;
DROP TABLE IF EXISTS `sellers` ;
DROP TABLE IF EXISTS `categories` ;
```

The table creation sequence starts with tables that do not have foreign keys.

```{sql connection=my_db, eval=FALSE}

------------- CREATE TABLE -------------

-- Customer Schema
CREATE TABLE IF NOT EXISTS `customers` (
  'id' INT PRIMARY KEY,
  'first_name' VARCHAR(250) NOT NULL,
  'last_name' VARCHAR(250) NOT NULL,
  'email' TEXT NOT NULL,
  'phone_number' VARCHAR(20),
  'date_of_birth' DATE,
  'billing_address_street_number' TEXT,
  'billing_address_street_name' TEXT,
  'billing_address_street_suffix' TEXT,
  'billing_address_city' TEXT,
  'billing_address_state' TEXT,
  'billing_address_country' TEXT,
  'billing_address_postcode' TEXT,
  'current_shipping_address_street_number' TEXT,
  'current_shipping_address_street_name' TEXT,
  'current_shipping_address_street_suffix' TEXT,
  'current_shipping_address_city' TEXT,
  'current_shipping_address_state' TEXT,
  'current_shipping_address_country' TEXT,
  'current_shipping_address_postcode' TEXT,
  'current_payment_method' VARCHAR(250)
);

-- Sellers Schema
CREATE TABLE IF NOT EXISTS `sellers` (
  'id' INT PRIMARY KEY,
  'name' VARCHAR(250) NOT NULL,
  'email' TEXT,
  'address_street_number' TEXT,
  'address_street_name' TEXT,
  'address_street_suffix' TEXT,
  'address_city' TEXT,
  'address_state' TEXT,
  'address_country' TEXT,
  'address_postcode' TEXT
);

-- Categories Schema
CREATE TABLE IF NOT EXISTS `categories` (
  'id' INT PRIMARY KEY,
  'name' VARCHAR(250) NOT NULL,
  'description' TEXT
);

-- Products Schema
CREATE TABLE IF NOT EXISTS `products` (
  'id' INT PRIMARY KEY,
  'seller_id' INT NOT NULL,
  'category_id' INT NOT NULL,
  'name' VARCHAR(60) NOT NULL,
  'color' VARCHAR(60) NOT NULL,
  'size' VARCHAR(5),
  'brand' VARCHAR(250),
  'price' NUMERIC NOT NULL,
  'currency' CHAR(3) NOT NULL, 
  'inventory' INT NOT NULL,
  FOREIGN KEY ('seller_id') 
    REFERENCES sellers ('id'),
  FOREIGN KEY ('category_id') 
    REFERENCES categories ('id')
);

-- Shipper Schema
CREATE TABLE IF NOT EXISTS `shippers` (
  'id' INT PRIMARY KEY,
  'name' CHAR(25) NOT NULL,
  'phone_number' VARCHAR(25) NOT NULL
);

-- Order Schema : create after 3 main tables
CREATE TABLE IF NOT EXISTS `orders` (
  'id' INT PRIMARY KEY,
  'customer_id' INT NOT NULL,
  'product_id' INT NOT NULL,
  'shipper_id' INT NOT NULL,
  'order_date' DATE NOT NULL,
  'order_time' TIMESTAMP NOT NULL,
  'quantity' INT NOT NULL,
  'discount' DECIMAL(3,2) NOT NULL,
  'rating_review' INT,
  FOREIGN KEY ('customer_id')
    REFERENCES customers ('id'),
  FOREIGN KEY ('product_id')
    REFERENCES products ('id'),
  FOREIGN KEY ('shipper_id')
    REFERENCES shippers ('id')
);

-- Ads Schema
CREATE TABLE IF NOT EXISTS `advertisements` (
  'id' INT PRIMARY KEY,
  'product_id' INT NOT NULL,
  'content' TEXT,
  'ad_clicks' INT,
  'budget' DECIMAL(10,2),
  'currency' CHAR(3),
  FOREIGN KEY ('product_id')
	REFERENCES products ('id')
);
```

#### Part 2: Data Generation and Management

#### Task 2.1: Synthetic Data Generation

The entire synthetic data is generated using Mockaroo using advanced field settings or Mockaroo specified coding language.

Foreign key is imported from other datasets by using field type as 'Dataset Column' then connecting to the other datasets where the foreign key comes from.

Field type as 'Formula' or 'Custom List' with dynamic distribution are utilised to set specific rules and conditions for the synthetic data generation as realistic as possible, for example:

-   Product names are conditional to category ID

-   Product size and price ranges are conditional to product name

-   Advertisement contents are conditional to product name

The data generation is a part of the dynamic process from data generation to data validation then data analysis. Data generation is revised whenever challenges incur during validation and analysis to ensure that the synthetic data simulates the real-world as much as possible.

#### Task 2.2: Data Import and Quality Assurance

In this task, we have performed data validation for entities in the database to maintain data quality and integrity. The validation process involves several key activities:

**1. Checking Duplicate Primary Key:** First, we check whether any of the primary keys present in the csv files have duplicates or not. If the number of unique values for a specific primary key column is equal to the total number of rows in the file, then there would be no duplicate primary key values. If there are duplicate entries, then an error message would pop up and the whole process would stop.

**2. Checking data quality and integrity:**

**2.1. Consistency Checks:** Consistency checks involve ensuring that the data conforms to business rules and logic. For instance, a payment status should correspond to a limited set of values (e.g., 'Pending', 'Completed', 'Rejected'), and a product category should be one that is predefined in the category table.

**2.2. Range & Constraint Checks:** This involves ensuring that numeric values fall within acceptable ranges (e.g., a rating field that should be between 1 and 5) and that string values meet constraints, such as a maximum length.

**2.3. Email Validation:** Email addresses are validated using regular expressions that define a pattern consistent with standard email formats. The validation ensures that only correctly formatted email addresses are accepted, which is critical for communication and user identification.

**2.4. Phone Numbers:** Phone numbers are validated using numeric values. The first digit for all phone numbers starts with "1" for country code, followed by 10 numeric values. However, we do not cover the international format and only consider phone numbers from the USA. This is checked in both "customers" and "shippers" entities.

**2.5. Date:** Order dates, present in the "order" entity, are validated using the YYYY-MM-DD format. The parser interprets the characters in the date according to this format and checks if they follow it. If the dates are valid, the system would indicate **'TRUE'**. If the dates are invalid, the system would indicate **'FALSE'**.

**2.6. Currency Code:** For the currency code, we assume that only USD is used. By standardising on a single currency code, the database is less complex and more consistent. This would also make sure the fluctuations in currency would not affect the change in prices.

**2.7. Price, Quantity, Budget & Ad Clicks:** Price from the "products" entity, quantity from the "orders" entity, budget and ad clicks from the "advertisements" entity are validated using an inequality, which states that these 3 attributes must be greater than 0 for their respective entities.

**2.8. Payment Method:** Payment method, present in the "customers" entity, is validated by checking whether an appropriate payment method is provided by the customer. This column cannot have null values.

**2.9. Discount:** Discount, present in the "orders" entity, is validated by checking whether each value in the column is between 0 to 100.

**2.10. Rating Review:** Rating review, present in the "orders" entity, is validated by checking whether each value in the column is either NA or a value from 1 to 5.

If any of the values present in the above attributes go against the set rules, a warning statement would pop up, indicating that specific row should be excluded.

**3. Checking Foreign Key**: After performing the integrity check, we check the foreign key. First, we check if there is/are foreign key(s) present in the file. If there are no foreign keys, the validation is skipped. If they are present in the file, the foreign key columns are extracted to a table for temporary processing. In this manner, all the csv files are checked. The foreign key values from the destination columns are, then, checked to see if they exist in the original columns. In a separate column, if the foreign key is present, the validation is set to **'TRUE'** and if the foreign key is missing, the validation is set to **'FALSE'**. The rows indicating 'FALSE' would be removed and the file would be updated.

The validation is, thus, completed.

### Part 3: Data Pipeline Generation

#### Task 3.1: GitHub Repository and Workflow Setup

For setting up the GitHub repository and workflow, we first create a new repository for our project on GitHub, and then clone it to our local machine using Git. This enables collaboration within our group, allowing everyone to work together and make changes to the project through GitHub. After cloning the repository locally, we add our database file, e-commerce data file, report file, as well as scripts for data validation, transformation, data analysis, and data visualization to the repository.

Within the 'database' file, an e-commerce database is created, and in the 'data upload' file, we upload all the generated data, including tables: advertisements, categories, customers, products, sellers, shippers. Within the 'main' file, we have data analysis visualizations file, and transformation, validation scripts.

#### Task 3.2: GitHub Actions for Continuous Integration

In order to set up the workflow, we use the "actions" part to create a new workflow file, then define the workflow "etl.yaml".

[**Will add workflow code**]{.underline}

For the workflow, we specify the actions as follows: 1. Specify that the workflow should run every 3 hours (pending) when changes are pushed to the main branch. 2. Define and build the job (sequence of tasks) to be executed. 3. Check out the code repository into the GitHub Actions runner. 4. Set up the R environment and cache R packages. 5. Install all the packages that we will use. 6. Execute the data transformation script from the main directory, checking for data quality and integrity of the new data that we update. (After data transformation and validation, it will trigger the running of the data analysis script, and the new analysis charts will be saved by month in the folder.) 7. Configure the git user email and name, adding all files in the database directory to the git staging area. 8. Finally, commit and push the changes to the main branch.

When performing incremental loading, the new loaded CSV file format for automation needs to be '

'\[table name\]\_YYYY-MM-DDTHHMMSS.csv' to read in the data.

Only the newly added files within the past two days will be processed, and we will obtain the primary key to check for duplicate primary keys first. Then, we will validate the quality and integrity of the new data, such as validating email and phone number formats. If errors occur, the uploaded error data will be removed while providing warnings for each invalid entry.

After data validation, we use the primary key to check if the row is unique. If it is, the row will be appended to the table. If the row already exists, we will update the existing row.

### Part 4: Data Analysis and Reporting with Quarto in R

#### Task 4.1: Advanced Data analysis in R

#### Task 4.2: Comprehensive Reporting with Quarto

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
1 + 1
```

```{r}

```

You can add options to executable code like this

```{r}
#| echo: false
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).
