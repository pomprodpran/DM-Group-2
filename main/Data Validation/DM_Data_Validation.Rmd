---
title: "Data Validation"
author: "5588069"
date: "Week 2"
output: 
  pdf_document: 
    toc: yes
    number_sections: yes
---
\newpage

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,comment = NA)
library(readr)
```

# Tidy Imports 

* There are several cases where we are required to guess, and ``recast`` types of variables to correspond to the nature of the attributes that we are dealing with in a *data schema*. 

>The term "schema" refers to the organization of data as a blueprint of how the database is constructed (divided into database tables in the case of relational databases)

* Tidy imports dictate two things: preservation of the original format and 
conversion from one format to the other *only once* ! 

## Standard import  

* By definition R is able to import delimited data in various forms and there are appropriate connectors here 

## The Brazilian Olist data 

* Olist is one of the key online retailers in Brazil - the data that are 
used here are from the kaggle challenge. You have to download the files 
and extract them on the same folder with the rmd file (the folder should 
be called _challenge_)


# The readr package 

```{r}
library(readr)
library(sqldf)
```

* So far we have seen a standard way of importing by using the ``read.csv`` function in this seminar we are going to examine the data using the read_csv function from the readr package. 


# File prefix and Suffix

```{r readr,attr.source='.numberLines'}
# lets first get a list of files 
files <- list.files("C:/Users/murali/OneDrive/Desktop/Data Management/Group Assignment/DM-Data-Validation/")
files

```


```{r prods}

#ok lets parse the products related file
products <- read_csv("products.csv")

```

* lets get it with the read.csv output 

```{r prodreadotcsv}

products2 <- read.csv("products.csv")
```


* Let us compare it 

```{r compare_readr_read.csv}
str(products)
str(products2)
```


*Explore the columns 

```{r colnames}
colnames(products)
```


```{r getheader}
head(products)
```

* Check if product_id is a primary key
```{r getindividualvalues}
length(unique(products$product_id)) == nrow(products)
```
## Data Validation

```{r}
advertisements <- read.csv("advertisements.csv")
categories <- read.csv("categories.csv")
customers <- read.csv("customers.csv")
orders <- read.csv("orders.csv")
#products <- read.csv("products.csv")
sellers <- read.csv("sellers.csv")
shippers <- read.csv("shippers.csv")
```


```{r}
## 1. products

# Check for duplicate records
#sqldf("SELECT * FROM products WHERE ROWID NOT IN (SELECT MIN(ROWID) FROM products GROUP BY product_id)")

# Check for missing values
#sqldf("SELECT * FROM products WHERE name IS NULL OR product_id IS NULL")

# Check for unique values
#sqldf("SELECT DISTINCT product_id, COUNT(*) FROM products GROUP BY product_id HAVING COUNT(*) > 1")

```

This result of "0" by checking for duplicate records, missing and unique values indicate that "products" entity does not exhibit any issues from the 3 types of checking.

```{r}
## 2. advertisements

# Check for duplicate records
#sqldf("SELECT * FROM advertisements WHERE ROWID NOT IN (SELECT MIN(ROWID) FROM advertisements GROUP BY ad_id)")

# Check for missing values
#sqldf("SELECT * FROM advertisements WHERE content IS NULL OR ad_id IS NULL")

# Check for unique values
#sqldf("SELECT DISTINCT ad_id, COUNT(*) FROM advertisements GROUP BY ad_id HAVING COUNT(*) > 1")
```

This result of "0" by checking for duplicate records, missing and unique values indicate that "advertisements" entity does not exhibit any issues from the 3 types of checking.




# Looping through - for 

```{r loop,message=FALSE,warning=FALSE,attr.source='.numberLines'}
# note we are already in week_02 so the root folder now 
# is /cloud/project/week_02/

all_files <- list.files("C:/Users/murali/OneDrive/Desktop/Data Management/Group Assignment/DM-Group-2 v2/data_upload/")

for (variable in all_files) {
  this_filepath <- paste0("C:/Users/murali/OneDrive/Desktop/Data Management/Group Assignment/DM-Group-2 v2/data_upload/",variable)
  this_file_contents <- readr::read_csv(this_filepath)
  
  number_of_rows <- nrow(this_file_contents)
  number_of_columns <- ncol(this_file_contents)
  
  print(paste0("The file: ",variable,
              " has: ",
              format(number_of_rows,big.mark = ","),
              " rows and ",
              number_of_columns," columns"))
}


```


## Check if the first column of each file is a primary 


```{r checkprimary,message=FALSE,warning=FALSE,attr.source='.numberLines'}

for (variable in all_files) {
  this_filepath <- paste0("C:/Users/murali/OneDrive/Desktop/Data Management/Group Assignment/DM-Group-2 v2/data_upload/",variable)
  this_file_contents <- readr::read_csv(this_filepath)
  number_of_rows <- nrow(this_file_contents)
  
  print(paste0("Checking for: ",variable))
  
  print(paste0(" is ",nrow(unique(this_file_contents[,1]))==number_of_rows))
}

```



# Load Files in an sqlite database 

```{r loadsqlite,warning=FALSE,error=FALSE,message=FALSE,attr.source='.numberLines'}
# Load the library
library(RSQLite)

#setup the connection
connection <- RSQLite::dbConnect(RSQLite::SQLite(),"ecommerse.db")

for (variable in all_files) {
  this_filepath <- paste0("C:/Users/murali/OneDrive/Desktop/Data Management/Group Assignment/DM-Group-2 v2/data_upload/",variable)
  this_file_contents <- readr::read_csv(this_filepath)

  table_name <- gsub(".csv","",variable) #variable or table_name? .csv is not being removed
  table_name <- variable
  
  RSQLite::dbWriteTable(connection,table_name,this_file_contents,overwrite=TRUE)
  
}
```

* lets look at what we got 

```{r listtables}
# Get a list of tables from the database that we already 
# created
RSQLite::dbListTables(connection)

```


* Do not forget to disconnect 


```{r disconnect}
# Disconnect from the database using the connection variable that we setup 
# before
RSQLite::dbDisconnect(connection)

```


# Storing them natively

## The RData format 

* A very standard approach on saving data is to stop the import/export game and start saving in a native format 

* R has its own native format that is called RData (.rda extension)

```{r rdata,message=FALSE,warning=FALSE,attr.source='.numberLines'}
all_files <- list.files("C:/Users/murali/OneDrive/Desktop/Data Management/Group Assignment/DM-Group-2 v2/data_upload/")
for (variable in all_files) {
  this_filepath <- paste0("C:/Users/murali/OneDrive/Desktop/Data Management/Group Assignment/DM-Group-2 v2/data_upload/",variable)
  this_file_contents <- readr::read_csv(this_filepath)
  table_name <- gsub(".csv","",variable)
  save(this_file_contents,file = paste0("rdadata/",table_name,".rda"))
}

#Error in gzfile(file, "wb") : cannot open the connection
```

* Load - you can load the individual file using 

```{r loadrda}
 load("rdadata/customers.rda")

#Error in readChar(con, 5L, useBytes = TRUE) : cannot open the connection
```

* Problem is that is saving an object with the same name when using load is not 
handy

## The RDS Data Format

```{r rdsdata,message=FALSE,warning=FALSE,attr.source='.numberLines'}
all_files <- list.files("C:/Users/murali/OneDrive/Desktop/Data Management/Group Assignment/DM-Group-2 v2/data_upload/")
for (variable in all_files) {
  this_filepath <- paste0("C:/Users/murali/OneDrive/Desktop/Data Management/Group Assignment/DM-Group-2 v2/data_upload/",variable)
  this_file_contents <- readr::read_csv(this_filepath)
  table_name <- gsub(".csv","",variable)
  saveRDS(this_file_contents,file = paste0("rdadata/",table_name,".rds"))
}

#Error in gzfile(file, mode) : cannot open the connection
```


* load now should give also the name of the object in the memory 

```{r rdsload}
customers_dataset <- readRDS("rdadata/customers_dataset.rds")
```

